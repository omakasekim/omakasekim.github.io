# TCP와 UDP

OSI 7계층에서 전송계층(Transport layer)에 속하는 데이터 전송 프로토콜이다. 여기선 중요한 것만 살펴보고 깊게는 들어가지 않는다.

## TCP (Transmission Control Protocol)

데이터가 반드시 전달되는 것을 보장하는 프로토콜로 다음 특징들을 갖는다.

* **연결지향(Connection-oriented)** 으로 2개의 호스트가 통신을 하기 전 연결이 이루어져야 한다.
* **높은 신뢰성(Reliability)** 과 **순서대로 전송하는 것(In-order delivery)** 을 보장한다.
  * **흐름 제어(Flow control)** 를 통해 송신자의 데이터 양을 조절한다.
  * **혼잡 제어(Congestion control)** 를 통해 네트워크 상황을 감지하고 송신자의 데이터 양을 조절한다.
  * **에러 감지(Error detection)** 를 통해 잘못 전송되었을 경우 재전송한다.
* **전 이중(Full duplex) 방식** 으로 두 호스트 모두 송신자와 수신자가 될 수 있다.
* **바이트 스트림(Byte stream)** 을 사용하여 데이터를 연속적인 바이트로 보고, **세그먼트(Segment)** 라는 단위의 패킷으로 쪼개서 보낸다.
*  HTTP, FTP, SMTP, TELNET 등에서 사용된다.

### 3-way handshaking

TCP가 호스트 간에 연결을 설정하는 방법으로 SYN/ACK 패킷을 통해 이루어진다. SYN 패킷은 동기화(SYNchronize)를 의미하는 패킷이며 ACK 패킷은 확인(ACKnowledgement)을 의미하는 패킷이다.

<img src="/image/3-way-handshake.png">

* **LISTEN** : 서버가 클라이언트의 연결요청을 기다리고 있다.
* **SYN_SENT** : 클라이언트가 능동적으로 서버에게 연결요청을 하자고 시퀀스 번호를 생성하여 SYN 패킷에 담아 보낸다. (능동 개방)
* **SYN_RECEIVED** : SYN 패킷을 받은 서버는 자신만의 시퀀스 번호를 생성하여 SYN 패킷에 담고 클라이언트의 SYN 패킷에 있는 시퀀스 번호에 1을 더해서 ACK 패킷에 담아 같이 보낸다.
* **클라이언트 ESTABLISHED** : SYN+ACK 패킷을 받은 클라이언트는 ACK 패킷의 시퀀스 번호를 보고 자신이 보낸 시퀀스 번호와 차이가 1임을 확인한다. 차이가 1이라면 제대로 연결되었다고 판단하고 서버의 SYN 패킷에 있는 시퀀스 번호에 1을 더해 ACK 패킷에 담아 보낸다.
* **서버 ESTABLISHED** : 클라이언트의 ACK 패킷을 받고 그 안의 시퀀스 번호가 보냈던 SYN 패킷의 시퀀스 번호 + 1이라면 연결이 되었다고 판단한다. 이후부터 본격적인 통신을 할 수 있게 된다.

### TCP 헤더의 구조
TCP의 세그먼트는 데이터 본체에 TCP 헤더가 붙은 형태로 구성된다.  
<img src="/image/TCP_Header.jpg" height="350px">

* `일련번호(sequence number)` : 송신한 바이트 수
* `확인 응답 번호(acknowledgement number)` : 수신한 바이트 수
* `데이터 옵셋(data offset)` : TCP 헤더의 길이
* `윈도우 사이즈(windows size)` : 한 번에 수신할 수 있는 데이터 크기
* `체크섬(checksum)` : 데이터가 훼손되었는지 확인하기 위한 정보

### 흐름 제어와 혼잡 제어
- `흐름 제어(flow control)`
    * `흐름 제어`는 `송신 측(호스트)과 수신 측(호스트)의 데이터 처리 속도 차이를 조절`하기 위한 기법이다.  
    * 수신 측은 도착한 패킷들을 버퍼에 쌓아 두는 것과 동시에 이미 버퍼에 쌓인 데이터를 순차적으로 꺼내서 처리하게 된다.  
    * 이때 만약 수신 측 컴퓨터의 성능이 낮다면 `데이터가 들어오는 속도보다 처리하는 속도가 느려져` 문제가 될 수 있다.  
    * 그래서 수신 측은 응답을 보낼 때 `윈도우 사이즈를 설정`하여 `현재 어느 정도까지 수신할 수 있는지`를 수시로 알려주게 된다.  
- `혼잡 제어(congestion control)`
    * `혼잡 제어`는 `네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지`하기 위한 기법이다.  
    * 송신 측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달된다.  
    * 만약 하나의 라우터에게 데이터가 몰릴 경우, 라우터는 자신에게 온 데이터를 모두 처리할 수 없다.  
    * 그렇게 되면 호스트들은 또 다시 재전송을 하게 되고 결국 혼잡을 가중시켜 오버플로우나 데이터 손실을 발생시킨다.
    * 따라서, 이러한 네트워크의 혼잡을 피하기 위해 송신 측에서 보내는 데이터의 전송 속도를 강제로 줄이게 된다.
<br>


## UDP (User Datagram Protocol)

TCP와 달리 데이터의 신뢰성을 보장하지 않는 프로토콜이며 다음 특징들을 갖는다.

* **비연결형(Connection-less)** 으로 연결을 설정하고 해제하는 과정이 없다.
* **신뢰성이 없고** 전송되는 **데이터의 순서를 보장하지 않는다.**
  * 흐름제어, 혼잡제어가 없다.
  * 에러감지는 헤더의 체크섬(Checksum)을 이용한 정도밖에 없다.
* 패킷의 단위가 **데이터그램(Datagram)** 으로 **경계가 분명** 하여 수신자는 송신자가 보낸 그대로의 크기로 받게 된다.
* 서버와 클라이언트는 유니캐스트(1:1), 브로드캐스트(1:N), 멀티캐스트(1:M)가 가능하다. (N은 전체, M은 일부)
* TCP에 비해서 하는 작업들이 굉장히 적기 때문에 **속도가 빠르다.**
* DNS, DHCP, 비디오/오디오 스트리밍 등에 사용된다.


### UDP 헤더 구조
UDP에서는 패킷에 해당하는 것을 `데이터그램`이라고 부른다.  
  
<img src="/image/UDP_Header.jpg" height="170px"> 
  
* `패킷 길이(UDP length)` : 헤더 길이와 데이터 길이의 합계
* `체크섬(checksum)` : 데이터가 훼손되었는지 확인하기 위한 정보

### 브로드캐스트 & 멀티캐스트
TCP에는 없는 기능으로 UDP에는 하나의 패킷을 여러 수신지에 전달하는 `브로드캐스트(broadcast)`와 `멀티캐스트(multicast)`라는 기능이 있다.  
* `브로드캐스트(broadcast)` 
    - local LAN 상에 붙어있는 모든 네트워크 장비들에게 보내는 통신이다.  
    - 통신의 대상이 특정한 한 네트워크가 아니라, 네트워크 안의 모든 장비들에게 통신을 하는 방식이라고 생각하면 된다.  
* `멀티캐스트(multicast)`
    - 보내고자 하는 정보를 그룹 내의 일정 네트워크 장비들에게만 한번에 보낼 수 있는 통신이다.  
    
<br>

## 3. TCP와 UDP의 차이점
|TCP|UDP|
|:---:|:---:|
| 연결지향형 프로토콜 | 비연결지향형 프로토콜 |
| 바이트 스트림을 통한 연결 | 메시지 스트림을 통한 연결 |
| 혼잡제어, 흐름제어 | 혼잡제어, 흐름제어 지원하지 않음 |
| 순서 보장, 상대적으로 느림 | 순서 보장되지 않음, 상대적으로 빠름 |
| 신뢰성 있는 데이터 전송, 안정적 | 데이터 전송을 보장하지 않음 |
| TCP 패킷은 세그먼트 | UDP 패킷은 데이터그램 |
| HTTP, 전자우편, 파일 전송에서 사용 | DNS, Broadcasting |

<br>
